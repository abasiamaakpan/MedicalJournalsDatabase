---
title: "R Notebook"
output: html_notebook
---

```{r}
# install packages and libraries
install.packages("RSQLite")
install.packages("RSQLServer")
install.packages("dplyr")
install.packages("tidyr")
install.packages('lubridate')
```

```{r}
library(dplyr)
library(tidyr)
library(DBI)
library(XML)
library(rlang)
library(lubridate)
```

```{r}
# create an ephemeral in-memory RSQLite database
con <- dbConnect(RSQLite::SQLite(), ":publications_db:")
```
## 2. XML Parsing and Loading data into the database

### 2.1 Authors: Parsing and Importing data
#### 2.1.2 Creating the Articles dataframe
```{r}
# define function to retrieve authors list
single_author_list <- function(xmlNode) {
  xmlNodeCopy <- duplicate(xmlNode)
  xcopy <- newXMLDoc(xmlNodeCopy)
  lastname <- xpathSApply(xcopy, '//LastName', xmlValue)
  firstname <- xpathSApply(xcopy, '//ForeName', xmlValue)
  initials <- xpathSApply(xcopy, '//Initials', xmlValue)
  
  return (paste(lastname, firstname, initials, sep='*'))
}

# parse attributes and elements on each authors node
get_authors <- function(xmlNode) {
  newxmlNodeCopy <- duplicate(xmlNode)
  pb<-newXMLDoc(newxmlNodeCopy)
  g <-newXMLDoc(xmlNode)
  names=xpathSApply(g,'//Author',single_author_list)
  names_single_string=paste(names,collapse='|')
  affiliation=xpathSApply(pb,'//Affiliation', xmlValue)
  return (paste(affiliation,names_single_string, sep='|'))
}

# read XML file and parse into DOM
xml_file <- "pubmed_sample.xml"
xmlDOM <- xmlParse(file = xml_file)
xmlRoot <- xmlRoot(xmlDOM)

# get authors list from XML file
author_list <- xpathSApply(xmlRoot,'//PubmedArticle//AuthorList', get_authors)

# add authors list to data frame
author_list_df <- tibble::enframe(author_list) %>%  separate(value, c('Affiliation', paste0('x', seq(12))), sep='\\|') %>% pivot_longer(starts_with('x'), names_to = 'index', values_to = 'data') %>% filter(!is.na(data)) %>% separate(col <- data, into = c('LastName', 'FirstName', 'Initial'), sep='\\*')

# format authors data frame
author_list_df_formatted <- author_list_df %>% distinct(FirstName, LastName, Initial)

authors_df_initial <- merge(author_list_df,  author_list_df_formatted, all.x=TRUE)

# remove extra columns from data frame
authors_df <- subset(authors_df_initial, select = -c(index,name))
authors_df <- tibble::rowid_to_column(authors_df, "authorID")

# print data frame
authors_df
```

#### 2.1.2 Creating the Article-Authors dataframe
```{r}
# create article-author data frame
authors_df_copy = authors_df_initial[4] %>% 
  dplyr::rename(
    articleID = name,
    )
article_authors_df <- tibble::rowid_to_column(authors_df_copy, "authorID")

# print data frame
article_authors_df
```

#### 2.1.3 Importing Authors and Article-Authors into the database
```{r}
# drop authors table if exists
res <- dbExecute(con, "
  DROP TABLE IF EXISTS authors;
")

# create authors table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS authors
  (
    author_id INTEGER PRIMARY KEY AUTOINCREMENT,
    last_name TEXT NOT NULL,
    first_name TEXT NOT NULL,
    initials TEXT NOT NULL,
    affiliation TEXT NOT NULL
  );
")

# load authors table
res <- dbSendQuery(con, "INSERT INTO authors (author_id, last_name, first_name, initials, affiliation) VALUES (:authorID, :LastName, :FirstName, :Initial, :Affiliation);", authors_df)
res <- dbSendQuery(con, "SELECT * FROM authors LIMIT 5;")
dbFetch(res)
```

```{r}
# drop article_author table if exists
res <- dbExecute(con, "
  DROP TABLE IF EXISTS article_author;
")

# create article_author table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS article_author
  (
    author_id INTEGER,
    article_id INTEGER,
    PRIMARY KEY(article_id, author_id),
    FOREIGN KEY (article_id) REFERENCES articles (article_id),
    FOREIGN KEY (author_id) REFERENCES authors (author_id)
  );
")

# load article authors table
res <- dbSendQuery(con, "INSERT INTO article_author (author_id, article_id) VALUES (:authorID, :articleID);", article_authors_df)
res <- dbSendQuery(con, "SELECT * FROM article_author LIMIT 5;")
dbFetch(res)
```

### 2.2 Journals: Parsing and Importing data
#### 2.2.1 Creating the Journals dataframe

### Creating the journal dataframe
```{r}
# read XML file and parse into DOM
xml_file <- "pubmed_sample.xml"
xmlDOM <- xmlParse(file = xml_file)
xmlRoot <- xmlRoot(xmlDOM)

# export journal ISSN
ISSN <- xpathSApply(xmlRoot, '//Article/Journal/ISSN', xmlValue)
JournalISSN <- tibble::enframe(ISSN)

# export journal issue
journalIssue <- xpathSApply(xmlRoot,'//Article//Journal/JournalIssue', xmlValue)
JIssue <- tibble::enframe(journalIssue)

# export journal issue volume
IssueVolume <- xpathSApply(xmlRoot, '//Article//Journal/JournalIssue/Volume', xmlValue)
JournalIssueVolume <- tibble::enframe(IssueVolume)

# export journal issue number
JournalIssueNumber <- xpathSApply(xmlRoot,'//Article//Journal/JournalIssue/Issue', xmlValue)
JournalIssueNumber <- tibble::enframe(JournalIssueNumber)

# export journal issue publication date
IssuePubDate <- xpathSApply(xmlRoot,'//Article//Journal/JournalIssue/PubDate', xmlValue)
JournalIssuePubDate <- tibble::enframe(IssuePubDate)

# export journal issue title
Title <- xpathSApply(xmlRoot,'//Article//Title', xmlValue)
JournalTitle <- tibble::enframe(Title)

# export journal ISO abbreviation
ISOAbbrev <- xpathSApply(xmlRoot,'//Article//ISOAbbreviation', xmlValue)
JournalISOAbbrev <- tibble::enframe(ISOAbbrev)

# format data into data frame
Journal_df <- data.frame(JournalISSN = JournalISSN[2], JournalIssueVolume = JournalIssueVolume[2], JournalIssueNumber = JournalIssueNumber[2], JournalIssuePubDate = JournalIssuePubDate[2], Title = JournalTitle[2], JournalISOAbbrev = JournalISOAbbrev[2])
Journal_df

journals_df_formatted <- Journal_df %>% 
  dplyr::rename(
    ISSN = value,
    Volume = value.1,
    Issue = value.2,
    PubDate = value.3,
    Title = value.4,
    ISOAbbrev = value.5
    )

# create journals data frame
journals_df <- tibble::rowid_to_column(journals_df_formatted, "JournalID")
journals_df
```
#### 2.1.3 Importing Journals into the database

```{r}
# drop journals table if exists
res <- dbExecute(con, "
  DROP TABLE IF EXISTS journals;
")

# create journals table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS journals
  (
    journal_id INTEGER PRIMARY KEY AUTOINCREMENT,
    issn TEXT NOT NULL,
    volume TEXT NOT NULL,
    issue INTEGER NOT NULL,
    pub_date DATE NOT NULL,
    title TEXT NOT NULL,
    iso_abbrev TEXT NOT NULL
  );
")

# load data into journals table
res <- dbSendQuery(con, "INSERT INTO journals (journal_id, issn, volume, issue, pub_date, title, iso_abbrev) VALUES (:JournalID, :ISSN, :Volume, :Issue, :PubDate, :Title, :ISOAbbrev);", journals_df)
res <- dbSendQuery(con, "SELECT * FROM journals LIMIT 5;")
dbFetch(res)
```

### 2.3 History: Parsing and Importing data
#### 2.3.1 Creating the History dataframe

```{r}
# helper function to add spacing
pad_string=function(x){
  x <- xmlValue(x)

  if (nchar(x) == 1) {
    return (paste0('0', x))
  }
  
  return (x)
}

# define function to retrieve the value and pubstatus attribute of each node
get_pub_status_and_value <- function(xmlNode) {
  x<-newXMLDoc(xmlNode)
  
  vec <- xpathSApply(x, '//PubMedPubDate/*', pad_string)
  datestring=paste(vec, collapse = '')
  
  return (paste(datestring, xmlGetAttr(xmlNode, 'PubStatus'), sep='|'))
}

# format each node of the subtree
history_columns <- function(xmlNode) {
  # create new tree of the sub-tree
  x <- newXMLDoc(xmlNode)
    
  # add delimiter to publication status
  vec=xpathSApply(x, '//PubMedPubDate', get_pub_status_and_value)
    
  # collapse the vector into a single string separated by asterisks
  return (paste(vec, collapse = '*'))
}

# read XML file and parse into DOM
xml_file <- "pubmed_sample.xml"
xmlDOM <- xmlParse(file = xml_file)
xmlRoot <- xmlRoot(xmlDOM)

# get history from XML file
history <- xpathSApply(xmlRoot, '//PubmedArticle//PubmedData/History', history_columns)

# create temporary history data frame
history_data <- tibble::enframe(history) %>%  separate(value, paste0('p', seq(10)), sep = '\\*') %>% pivot_longer(!name,names_to = 'index', values_to = 'data') %>% filter(!is.na(data)) %>% separate(col = data, into = c('Date', 'PubStatus'), sep = '\\|')

# format date column
date_formatted <- history_data %>% transmute(PubDate = ymd(substr(Date, 1, 8)))

# update temporary dataframe
history_df_temp <- data.frame(publishStatus <- history_data[4], DateColumn <- date_formatted)

# create history data frame
history_df <- tibble::rowid_to_column(history_df_temp, "HistoryID")
history_df 
```

#### 2.3.2 Creating the Article-History dataframe

```{r}
articleID = history_data[1]
articleID %>% dplyr::rename(article_id = name)

# format article-history data frame
article_history_df <- data.frame(historyid = history_df[1], articleidentifier = newarticleID)
article_history_df <- article_history_df %>% dplyr::rename(ArticleID = name)

# create article-history data frame
article_history_df
```

#### 2.3.3 Importing History and Article-History into the database
```{r}
# drop history table if exists
res <- dbExecute(con, "
  DROP TABLE IF EXISTS history;
")

# create history table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS history
  (
    history_id INTEGER PRIMARY KEY AUTOINCREMENT,
    pub_status TEXT NOT NULL,
    pub_date DATE NOT NULL
  );
")

# load history table
res <- dbSendQuery(con, "INSERT INTO history (history_id, pub_status, pub_date) VALUES (:HistoryID, :PubStatus, :PubDate);", history_df)
res <- dbSendQuery(con, "SELECT * FROM history LIMIT 5;")
dbFetch(res)
```

```{r}
# drop article_history table if exists
res <- dbExecute(con, "
  DROP TABLE IF EXISTS article_history;
")

# create article_history table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS article_history
  (
    history_id INTEGER,
    article_id INTEGER,
    PRIMARY KEY(article_id, history_id),
    FOREIGN KEY (article_id) REFERENCES articles (article_id),
    FOREIGN KEY (history_id) REFERENCES history (history_id)
  );
")

# load data into article history table
res <- dbSendQuery(con, "INSERT INTO article_history (history_id, article_id) VALUES (:HistoryID, :ArticleID);", article_history_df)
res <- dbSendQuery(con, "SELECT * FROM article_history LIMIT 5;")
dbFetch(res)
```

### 2.4 Abstracts: Parsing and Importing data
#### 2.4.1 Creating the Abstracts and Article-Abstracts dataframe

```{r}
# read XML file and parse into DOM
xml_file <- "pubmed_sample.xml"
xmlDOM <- xmlParse(file = xml_file)
xmlRoot <- xmlRoot(xmlDOM)

# get all abstract nodes
# LOOKS LIKE THIS DOESN'T DO ANYTHING
abstract <- xpathSApply(xmlRoot,'//PubmedArticle//Article/Abstract', xmlValue)

# define function to parse each abstract node 
abstract_parse <- function(xmlNode) {
  # make copy of node
  xmlNodeCopy <- duplicate(xmlNode)
  # create new XML
  x <- newXMLDoc(xmlNodeCopy)
  
  xmlNodeCopy_1 <- duplicate(xmlNode)
  y <- newXMLDoc(xmlNodeCopy_1)
  xmlNodeCopy_2 <- duplicate(xmlNode)
  
  z <- newXMLDoc(xmlNodeCopy_2)
  
  # extract XML attributes and value
  Label <- xpathSApply(x, '//AbstractText', xmlGetAttr, 'Label')
  NMLCategory <- xpathSApply(y, '//AbstractText', xmlGetAttr, 'NlmCategory')
  Text <- xpathSApply(z, '//AbstractText', xmlValue)

  return (paste(Label, NMLCategory, Text, collapse='|',sep='*'))
}

# get article nodes
abstracts <- xpathSApply(xmlRoot, '//Article', abstract_parse)

abstracts_df_temp <- tibble::enframe(abstracts) %>% separate(value, paste0('a', seq(10)), sep = '\\|') %>% pivot_longer(!name, names_to = 'index', values_to = 'data') %>% filter(!is.na(data)) %>% separate(col = data, into = c('Label','NMLCategory','Content'), sep='\\*')

# rename column
abstracts_df_temp <- abstracts_df_temp %>% dplyr::rename(ArticleID = name)

# exclude index column 
abstracts_df_formatted <- subset(abstracts_df_temp, select = -c(index))
abstracts_df_formatted <- tibble::rowid_to_column(abstracts_df_formatted, "AbstractID")

# exclude ArticleID column 
abstracts_df <- subset(abstracts_df_formatted, select = -c(ArticleID))

# create abstracts data frame
abstracts_df
```
```{r}
# create article-abstract data frame
article_abstract_df <- subset(abstracts_df_formatted, select = -c(Label, NMLCategory, Content))
article_abstract_df
```

#### 2.3.3 Importing Abstracts and Article-Abstract into the database
```{r}
# drop abstracts table if exists
res <- dbExecute(con, "
  DROP TABLE IF EXISTS abstracts;
")

# create abstracts table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS abstracts
  (
    abstract_id INTEGER PRIMARY KEY AUTOINCREMENT,
    label TEXT NOT NULL,
    nml_category TEXT NOT NULL,
    content TEXT NOT NULL
  );
")

# load history table
res <- dbSendQuery(con, "INSERT INTO abstracts (abstract_id, label, nml_category, content) VALUES (:AbstractID, :Label, :NMLCategory, :Content);", abstracts_df)
res <- dbSendQuery(con, "SELECT * FROM abstracts LIMIT 5;")
dbFetch(res)
```

```{r}
# drop article_abstract table if exists
res <- dbExecute(con, "
  DROP TABLE IF EXISTS article_abstract;
")

# create article_history table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS article_abstract
  (
    abstract_id INTEGER,
    article_id INTEGER,
    PRIMARY KEY(article_id, abstract_id),
    FOREIGN KEY (article_id) REFERENCES articles (article_id),
    FOREIGN KEY (abstract_id) REFERENCES abstracts (abstract_id)
  );
")

# load data into article abstract table
res <- dbSendQuery(con, "INSERT INTO article_abstract (abstract_id, article_id) VALUES (:AbstractID, :ArticleID);", article_abstract_df)
res <- dbSendQuery(con, "SELECT * FROM article_abstract LIMIT 5;")
dbFetch(res)
```

### 2.5 Elocations: Parsing and Importing data
#### 2.5.1 Creating the Elocations and Article-Elocations dataframe

### Creating the Elocations and Article-Elocations dataframe
```{r}
# LOOKS LIKE THIS DOESN'T DO ANYTHING
elocation <- xpathSApply(xmlRoot, '//ELocationID', xmlValue)

# define helper function to parse each elocation node
elocation_parser <- function(xmlNode) {
  # copy node
  xmlNodeCopy <- duplicate(xmlNode)
  # create new XML document from copied node
  x <- newXMLDoc(xmlNodeCopy)
  
  # copy node
  xmlNodeCopy_1 <- duplicate(xmlNode)
  # create new XML document from copied node
  y <- newXMLDoc(xmlNodeCopy_1)
  
  # get attributes and value of elocation
  EIdType <- xpathSApply(x, '//ELocationID', xmlGetAttr, 'EIdType')
  ELocationID <- xpathSApply(y, '//ELocationID', xmlValue)

  return (paste(EIdType, ELocationID, collapse = '|', sep = '*'))
}

# read XML file and parse into DOM
xml_file <- "pubmed_sample.xml"
xmlDOM <- xmlParse(file = xml_file)
xmlRoot <- xmlRoot(xmlDOM)

# get article nodes
elocations <- xpathSApply(xmlRoot, '//Article', elocation_parser)

elocations_df_temp <- tibble::enframe(elocations) %>% separate(value, paste0('e', seq(10)), sep='\\|') %>% pivot_longer(!name, names_to = 'index', values_to = 'data') %>% filter(!is.na(data)) %>% separate(col = data, into = c('type', 'content'), sep = '\\*')

# add elocation id column
elocations_df <- tibble::rowid_to_column(elocations_df_temp, "ElocID")

# exclude name and index column
elocations_df <- subset(elocations_df, select = -c(name, index))

# print elocation data frame
elocations_df
```
#### TODO: CHECK ELOCATIONS DF, UPDATE ARTICLE-ELOCATION DF, CHECK DATA QUALITY ON BOTH, IMPORT BOTH 
```{r}
# read XML file and parse into DOM
xml_file <- "pubmed_sample.xml"
xmlDOM <- xmlParse(file = xml_file)
xmlRoot <- xmlRoot(xmlDOM)

elocation=xpathSApply(xmlRoot,'//ELocationID', xmlValue)
#elocation
```


```{r}
# Takes an xml node and it returns the value and pubstatus attribute of that node. Also pads the date string
geloc=function(xmlNode){
  #print(xmlNode)
    xmlNodeCopy <- duplicate(xmlNode)
    x<-newXMLDoc(xmlNodeCopy)
    xmlNodeCopy_1 <- duplicate(xmlNode)
    y<-newXMLDoc(xmlNodeCopy_1)
    #y<<-xmlNodeCopy
    vec=xpathSApply(x,'//ELocationID',xmlGetAttr,'EIdType')
    vec1=xpathSApply(y,'//ELocationID',xmlValue)

    #datestring=paste(vec, collapse = '')
  return (paste(vec,vec1, collapse='|',sep='*'))
}
```

```{r}
# read XML file and parse into DOM
xml_file <- "pubmed_sample.xml"
xmlDOM <- xmlParse(file = xml_file)
xmlRoot <- xmlRoot(xmlDOM)
  elocation_df=xpathSApply(xmlRoot,'//Article',geloc)
  #elocation_df
```

```{r}
  elocation_df_new=tibble::enframe(  elocation_df)%>%  separate(value,paste0('e',seq(10)),sep='\\|') %>% pivot_longer(!name,names_to='index',values_to='data') %>% filter(!is.na(data)) %>% separate(col=data, into = c('type','content'),sep='\\*')
```
```{r}
  elocation_df_new
```


```{r}
 elocation_df_new <- tibble::rowid_to_column( elocation_df_new, "elocID")
 elocation_df_new
```


```{r}
 elocation_df_new <- subset( elocation_df_new, select = -c(name,index))
elocation_df_new
```

```{r}
 elocation_df_new
 test_elocation_df_new=elocation_df_new %>% distinct(type)
 test_elocation_df_new
 test_elocation_df_new_final <- tibble::rowid_to_column( test_elocation_df_new, "elocID")
 test_elocation_df_new_final
```
```{r}
datC <- merge( test_elocation_df_new_final,  elocation_df_new, all.x=TRUE)
datC
```
## elocation DF


```{r}
#elocation_df_final_df=datC %>% 
  #dplyr::rename(
  #  articleID = elocID,
   # elocID=typeID
    #)
```
### Creating the article elocation  dataframe

```{r}

elocation_df_final_df_done <- subset( elocation_df_final_df, select = -c(type,content))
elocation_df_final_df_done
```

```{r}
#elocation_df_done <- #data.frame(articleid=elocation_df_final_df[3],elocid=elocation_df_final_df[2])
#elocation_df_done
```

### 2.6 Publication Types: Parsing and Importing data
#### 2.6.1 Creating the Publication Types dataframe
```{r}
# define function to retrieve publication type node
get_pub_type <- function(xmlNode) {
  gtb <- newXMLDoc(xmlNode)
  
  PublicationTypeList <- xpathSApply(gtb, '//PublicationTypeList/*', xmlValue)
  
  return (paste(PublicationTypeList))
}

# define function to retrieve publication type node
pub_type_columns <- function(xmlNode) {
  publication <- newXMLDoc(xmlNode)
  publication_vec <- xpathSApply(publication, '//PublicationTypeList', get_pub_type)

  return (paste(publication_vec, collapse = '*'))
}

# read XML file and parse into DOM
xml_file <- "pubmed_sample.xml"
xmlDOM <- xmlParse(file = xml_file)
xmlRoot <- xmlRoot(xmlDOM)

# get publication types list
publication_type <- xpathSApply(xmlRoot, '//PubmedArticle//PublicationTypeList', pub_type_columns)

pub_types_df_temp <- tibble::enframe(publication_type) %>% separate(value, paste0('p', seq(10)), sep = '\\*') %>% pivot_longer(!name, names_to = 'index', values_to = 'data') %>% filter(!is.na(data)) %>% separate(col = data, into = c('Type'), sep = '\\*')

# format data frame
pub_types_df_temp <- subset(pub_types_df_temp, select = -c(index))
pub_types_df_temp <- pub_types_df_temp %>% dplyr::rename(ArticleID = name)

# only show unique type values
pub_types_df <- pub_types_df_temp %>% distinct(Type)

# add publication type id column
pub_types_df <- tibble::rowid_to_column(pub_types_df, "PubTypeID")

# return publication type data frame
pub_types_df
```
#### 2.6.2 Creating the Article-Publication Types dataframe
```{r}
# create article publication type data frame
article_pub_type_df <- merge(pub_types_df, pub_types_df_temp, all.x = TRUE)
article_pub_type_df <- subset(article_pub_type_df, select = -c(Type))

# return article publication type data frame
article_pub_type_df
```

#### 2.6.3 Importing Publication Types and Article-Publication Types into the database
```{r}
# drop pub_types table if exists
res <- dbExecute(con, "
  DROP TABLE IF EXISTS pub_types;
")

# create pub_types table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS pub_types
  (
    pub_type_id INTEGER PRIMARY KEY AUTOINCREMENT,
    pub_name TEXT NOT NULL
  );
")

# load history table
res <- dbSendQuery(con, "INSERT INTO pub_types (pub_type_id, pub_name) VALUES (:PubTypeID, :Type);", pub_types_df)
res <- dbSendQuery(con, "SELECT * FROM pub_types LIMIT 5;")
dbFetch(res)
```

```{r}
# drop article_pub_type table if exists
res <- dbExecute(con, "
  DROP TABLE IF EXISTS article_pub_type;
")

# create article_pub_type table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS article_pub_type
  (
    pub_type_id INTEGER,
    article_id INTEGER,
    PRIMARY KEY(article_id, pub_type_id),
    FOREIGN KEY (article_id) REFERENCES articles (article_id),
    FOREIGN KEY (pub_type_id) REFERENCES pub_types (pub_type_id)
  );
")

# load data into article_pub_type table
res <- dbSendQuery(con, "INSERT INTO article_pub_type (pub_type_id, article_id) VALUES (:PubTypeID, :ArticleID);", article_pub_type_df)
res <- dbSendQuery(con, "SELECT * FROM article_pub_type LIMIT 5;")
dbFetch(res)
```

### 2.7 Grants: Parsing and Importing data
#### 2.7.1 Creating the Grants dataframe

```{r}
# define function parse each grant node
get_grant <- function(xmlNode) {
  # make copy of grant node
  xmlNodeCopy <- duplicate(xmlNode)
  grant <- newXMLDoc(xmlNodeCopy)
  
  GrantId <- xpathSApply(grant, '//GrantID', xmlValue)
  Acronym <- xpathSApply(grant, '//Acronym', xmlValue)
  Agency <- xpathSApply(grant, '//Agency', xmlValue)
  Country <- xpathSApply(grant, '//Country', xmlValue)

  return (paste(GrantId, Acronym, Agency, Country, sep = '*'))
}

# get columns of grants
get_grant_columns <- function(xmlNode) {
  xmlNodeCopy <- duplicate(xmlNode)
  grant <- newXMLDoc(xmlNodeCopy)
  
  grant_vec <- xpathSApply(grant, '//Grant', get_grant)
  
  # collapse the vector into a single string separated by pipe characters
  return (paste(grant_vec, collapse = '|'))
}

# get list of grants
get_grants_list <- function(xmlNode) {
  xmlNodeCopy <- duplicate(xmlNode)
  grant <- newXMLDoc(xmlNodeCopy)
  grant_check <- xpathSApply(grant, '//GrantList', get_grant_columns)

  if(length(grant_check) == 0) {
    return ('')
  }
  
  return (grant_check)
}

# read XML file and parse into DOM
xml_file <- "pubmed_sample.xml"
xmlDOM <- xmlParse(file = xml_file)
xmlRoot <- xmlRoot(xmlDOM)

# get grants list from articles
grants = xpathSApply(xmlRoot, '//Article', get_grants_list)

# set up grants data frame
grants_df_temp <- tibble::enframe(grants) %>%  separate(value, paste0('g', seq(10)), sep = '\\|') %>% pivot_longer(!name, names_to = 'index', values_to = 'data') %>% filter(!is.na(data)) %>% separate(col = data, into = c('GrantID', 'Acronym', 'Agency', 'Country'), sep = '\\*')

# format grants data frame
grants_df_temp <- tibble::rowid_to_column(grants_df_temp, "ArticleID")

# assign columns to data frame
grants_df_temp <- data.frame(ArticleID = grants_df_temp[2], GrantID = grants_df_temp[4], Acronym = grants_df_temp[5], Agency = grants_df_temp[6], Country = grants_df_temp[7])

# remove duplicate records
grants_df <- grants_df_temp %>% distinct(GrantID, Agency, Acronym)

# return grants data frame
grants_df
```

#### 2.7.2 Creating the Article-Grant dataframe
```{r}
article_grant_df <- data.frame(ArticleID = grants_df_temp[1], GrantID = grants_df_temp[2])

# delete duplicate records
article_grant_df <- article_grant_df_temp %>% distinct(name, GrantID)

# rename ArticleID column
article_grant_df <- article_grant_df %>% dplyr::rename(ArticleID = name)

# return article grant data frame 
article_grant_df
```
#### 2.7.3 Importing Grants and Article-Grants into the database
```{r}
# drop grants table if exists
res <- dbExecute(con, "
  DROP TABLE IF EXISTS grants;
")

# create grants table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS grants
  (
    grant_id INTEGER PRIMARY KEY AUTOINCREMENT,
    id TEXT,
    acronym TEXT NOT NULL,
    agency TEXT NOT NULL,
    country TEXT NOT NULL
  );
")

# load history table
res <- dbSendQuery(con, "INSERT INTO grants (grant_id, id, acronym, agency, country) VALUES (:UniqueGrantID, :GrantId, :Acronym, :Agency, :Country);", grants_df)
res <- dbSendQuery(con, "SELECT * FROM grants LIMIT 5;")

dbFetch(res)
```

```{r}
# drop article_grant table if exists
res <- dbExecute(con, "
  DROP TABLE IF EXISTS article_grant;
")

# create article_grant table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS article_grant
  (
    grant_id TEXT,
    article_id INTEGER,
    PRIMARY KEY(article_id, grant_id),
    FOREIGN KEY (article_id) REFERENCES articles (article_id),
    FOREIGN KEY (grant_id) REFERENCES grants (grant_id)
  );
")

# load data into article_grant table
res <- dbSendQuery(con, "INSERT INTO article_grant (grant_id, article_id) VALUES (:UniqueGrantID, :ArticleID);", article_pub_type_df)
res <- dbSendQuery(con, "SELECT * FROM article_grant LIMIT 5;")
dbFetch(res)
```

## Creating the article dataframe

```{r}
articleDetails = xpathSApply(xmlRoot,'//Article', xmlValue)
#articleDetails
#tibble::enframe(articleDetails)

```

```{r}
final_Journal_df
```

```{r}
articlepubModel = xpathSApply(xmlRoot,'//Article', xmlGetAttr,'PubModel')
#articlepubModel
```


```{r}
articletitle = xpathSApply(xmlRoot,'//Article/ArticleTitle', xmlValue)
#articletitle
```
```{r}
articlep= xpathSApply(xmlRoot,'//Article/Pagination', xmlValue)
articlep
```


```{r}
get_date=function(xmlNode){
  xmlNodeCopy3 <- duplicate(xmlNode)
  gd<-newXMLDoc(xmlNodeCopy3)
  get_date_check= xpathSApply(gd,'//ArticleDate', xmlValue)

  if(length(get_date_check)==0){
    return ("")
  }
  return (get_date_check)

}

```


```{r}
articled= xpathSApply(xmlRoot,'//Article', get_date)
articled
```

```{r}
articlel= xpathSApply(xmlRoot,'//Article/Language', xmlValue)
#articlel
```

```{r}
grabbing_index <- tibble::rowid_to_column(final_Journal_df, "articleID")
#grabbing_index
#articlel
#unlist(grabbing_index[1])
```


```{r}
article_df_final <- data.frame(articleid=grabbing_index[1],journalid=grabbing_index[2],pubModel=articlepubModel,articleTitle=articletitle,pagination=articlep,date=articled,language=articlel)
article_df_final
```
## Article DF
```{r}
article_df_final$date=ymd(article_df_final$date)
article_df_final
```

### Creating a database and tables

```{r}

# CREATE TABLES
# create journals table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS journals
  (
    journal_id INTEGER PRIMARY KEY AUTOINCREMENT,
    issn TEXT NOT NULL,
    volume TEXT NOT NULL,
    issue INTEGER NOT NULL,
    pub_date DATE NOT NULL,
    title TEXT NOT NULL,
    iso_abbrev TEXT NOT NULL
  );
")

# create articles table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS articles
  (
    article_id INTEGER PRIMARY KEY AUTOINCREMENT,
    journal_id TEXT,
    pub_model TEXT NOT NULL,
    title TEXT NOT NULL,
    pagination INTEGER NOT NULL,
    pub_date DATE NOT NULL,
    lang TEXT NOT NULL,
    FOREIGN KEY (journal_id) REFERENCES journalS (journal_id)
  );
")

# create authors table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS authors
  (
    author_id INTEGER PRIMARY KEY AUTOINCREMENT,
    last_name TEXT NOT NULL,
    first_name TEXT NOT NULL,
    initials TEXT NOT NULL,
    affiliation TEXT NOT NULL
  );
")

# create article authorship table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS article_author
  (
    article_id INTEGER,
    author_id INTEGER,
    PRIMARY KEY(article_id, author_id),
    FOREIGN KEY (article_id) REFERENCES articles (article_id),
    FOREIGN KEY (author_id) REFERENCES authors (author_id)
  );
")

# create history table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS history
  (
    history_id INTEGER PRIMARY KEY AUTOINCREMENT,
    pub_date DATE NOT NULL,
    pub_status TEXT NOT NULL
  );
")

# create article history table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS article_history
  (
    article_id INTEGER,
    history_id INTEGER,
    PRIMARY KEY(article_id, history_id),
    FOREIGN KEY (article_id) REFERENCES articles (article_id),
    FOREIGN KEY (history_id) REFERENCES history (history_id)
  );
")

# create abstracts table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS abstracts
  (
    abstract_id INTEGER PRIMARY KEY AUTOINCREMENT,
    label TEXT NOT NULL,
    nml_category TEXT NOT NULL,
    content TEXT NOT NULL
  );
")

# create article abstracts table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS article_abstract
  (
    abstract_id INTEGER,
    article_id INTEGER,
    PRIMARY KEY(article_id, abstract_id),
    FOREIGN KEY (article_id) REFERENCES articles (article_id),
    FOREIGN KEY (abstract_id) REFERENCES abstracts (abstract_id)
  );
")

# create elocations table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS elocations
  (
    elocation_id INTEGER PRIMARY KEY AUTOINCREMENT,
    eloc_type TEXT NOT NULL,
    content TEXT NOT NULL
  );
")

# create elocations table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS article_elocations
  (
    article_id INTEGER,
    elocation_id INTEGER,
    PRIMARY KEY(article_id, elocation_id),
    FOREIGN KEY (article_id) REFERENCES articles (article_id),
    FOREIGN KEY (elocation_id) REFERENCES elocations (elocation_id)
  );
")

# create publication types table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS pub_types
  (
    pub_type_id INTEGER PRIMARY KEY AUTOINCREMENT,
    pub_type TEXT NOT NULL
  );
")

# create article publication types table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS article_pub_type
  (
    pub_type_id INTEGER,
    article_id INTEGER,
    PRIMARY KEY(article_id, pub_type_id),
    FOREIGN KEY (article_id) REFERENCES articles (article_id),
    FOREIGN KEY (pub_type_id) REFERENCES pub_types (pub_type_id)
  );
")

# create grants table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS grants
  (
    grant_id TEXT PRIMARY KEY,
    acronym TEXT NOT NULL,
    agency TEXT NOT NULL,
    country TEXT NOT NULL
  );
")

# create article grants table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS article_grant
  (
    article_id INTEGER,
    grant_id TEXT,
    PRIMARY KEY(article_id, grant_id),
    FOREIGN KEY (article_id) REFERENCES articles (article_id),
    FOREIGN KEY (grant_id) REFERENCES grants (grant_id)
  );
")
```

## Loading data into the database
Since I have already created the tables, I will load the `Book` data frame by using placeholders in the query definition and matching each value to columns in the data frame. I will repeat this step for each table.

```{r}
# load journals table
res <- dbSendQuery(con, "INSERT INTO journals (journal_id, issn, volume, issue, pub_date, title, iso_abbrev) VALUES (:journalID, :ISSN, :Volume, :Issue, :PubDate, :title, :ISOAbbrev);", article_journal_initial_df)
res <- dbSendQuery(con, "SELECT * FROM journals LIMIT 5;")
dbFetch(res)
```

```{r}
# load articles table
res <- dbSendQuery(con, "INSERT INTO articles (article_id, journal_id, pub_model, title, pagination, pub_date, lang) VALUES (:articleid, :journalid, :pubModel, :articleTitle, :pagination, :date, :language);", article_df_final)
res <- dbSendQuery(con, "SELECT * FROM history LIMIT 5;")
dbFetch(res)
```

```{r}
# load authors table
res <- dbSendQuery(con, "INSERT INTO authors (author_id, last_name, first_name, initials, affiliation) VALUES (:newDate, :PubStatus);", daAuthor)
res <- dbSendQuery(con, "SELECT * FROM authors LIMIT 5;")
dbFetch(res)
```

```{r}
# load article authors table
res <- dbSendQuery(con, "INSERT INTO article_author (author_id, article_id) VALUES (:authorID, :areticleID);", dArticle_Authors)
res <- dbSendQuery(con, "SELECT * FROM history LIMIT 5;")
dbFetch(res)
```

```{r}
# load history table
res <- dbSendQuery(con, "INSERT INTO history (pub_date, pub_status) VALUES (:newDate, :PubStatus);", new_history_prelim_df)
res <- dbSendQuery(con, "SELECT * FROM history LIMIT 5;")
dbFetch(res)
```

```{r}
# load article history
res <- dbSendQuery(con, "INSERT INTO article_history (article_id, history_id) VALUES (:name, :historyID);", article_history_df)
res <- dbSendQuery(con, "SELECT * FROM article_history LIMIT 5;")
dbFetch(res)
```


```{r}
# load abstracts
res <- dbSendQuery(con, "INSERT INTO abstracts (abstract_id, label, nml_category, content) VALUES (:abstractID, :label, :nlmCategory, :content);", abstract_all)
res <- dbSendQuery(con, "SELECT * FROM abstracts LIMIT 5;")
dbFetch(res)
```

```{r}
# load abstract article
res <- dbSendQuery(con, "INSERT INTO article_abstract (abstract_id, article_id) VALUES (:abstractID, :articleID);", abstract_df_new_all)
res <- dbSendQuery(con, "SELECT * FROM article_abstract LIMIT 5;")
dbFetch(res)
```

```{r}
# load elocations
res <- dbSendQuery(con, "INSERT INTO elocations (elocation_id, eloc_type, content) VALUES (:elocationID, :elocationType, :content);", test_elocation_df_new_final)
res <- dbSendQuery(con, "SELECT * FROM elocations LIMIT 5;")
dbFetch(res)
```

```{r}
# load article elocations
res <- dbSendQuery(con, "INSERT INTO article_elocations (article_id, elocation_id) VALUES (:elocationID, :articleID);", elocation_df_final_df_done)
res <- dbSendQuery(con, "SELECT * FROM elocations LIMIT 5;")
dbFetch(res)
```

```{r}
# load publication types
res <- dbSendQuery(con, "INSERT INTO pub_types (pub_type_id, pub_type) VALUES (:pubTypeID, :type);", pubtype_new_df_final)
res <- dbSendQuery(con, "SELECT * FROM elocations LIMIT 5;")
dbFetch(res)
```

```{r}
# load article publication types
res <- dbSendQuery(con, "INSERT INTO article_pub_type (pub_type_id, article_id) VALUES (:pubTypeID, :articleID);", pubtype_new_df_final_done)
res <- dbSendQuery(con, "SELECT * FROM article_pub_type LIMIT 5;")
dbFetch(res)
```