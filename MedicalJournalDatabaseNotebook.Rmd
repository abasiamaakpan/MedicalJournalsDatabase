---
title: "R Notebook"
output: html_notebook
---

```{r}
# install packages and libraries
install.packages("RSQLite")
install.packages("RSQLServer")
install.packages("dplyr")
install.packages("tidyr")
install.packages('lubridate')
```

```{r}
library(dplyr)
library(tidyr)
library(DBI)
library(XML)
library(rlang)
library(lubridate)
```

```{r}
# create an ephemeral in-memory RSQLite database
con <- dbConnect(RSQLite::SQLite(), ":publications_db:")
```

### 1.1 Authors: Parsing and Importing data
#### 1.1.2 Creating the Articles dataframe
```{r}
# define function to retrieve authors list
single_author_list <- function(xmlNode) {
  xmlNodecopy <- duplicate(xmlNode)
  xcopy <- newXMLDoc(xmlNodecopy)
  lastname <- xpathSApply(xcopy, '//LastName', xmlValue)
  firstname <- xpathSApply(xcopy, '//ForeName', xmlValue)
  initials <- xpathSApply(xcopy, '//Initials', xmlValue)
  
  return (paste(lastname, firstname, initials, sep='*'))
}

# parse attributes and elements on each authors node
get_authors <- function(xmlNode) {
  newxmlNodecopy <- duplicate(xmlNode)
  pb<-newXMLDoc(newxmlNodecopy)
  g <-newXMLDoc(xmlNode)
  names=xpathSApply(g,'//Author',single_author_list)
  names_single_string=paste(names,collapse='|')
  affiliation=xpathSApply(pb,'//Affiliation', xmlValue)
  return (paste(affiliation,names_single_string, sep='|'))
}

# read XML file and parse into DOM
xml_file <- "pubmed_sample.xml"
xmlDOM <- xmlParse(file = xml_file)
xmlRoot <- xmlRoot(xmlDOM)

# get authors list from XML file
author_list <- xpathSApply(xmlRoot,'//PubmedArticle//AuthorList', get_authors)

# add authors list to data frame
author_list_df <- tibble::enframe(author_list) %>%  separate(value, c('Affiliation', paste0('x', seq(12))), sep='\\|') %>% pivot_longer(starts_with('x'), names_to = 'index', values_to = 'data') %>% filter(!is.na(data)) %>% separate(col <- data, into = c('LastName', 'FirstName', 'Initial'), sep='\\*')

# format authors data frame
author_list_df_formatted <- author_list_df %>% distinct(FirstName, LastName, Initial)

authors_df_initial <- merge(author_list_df,  author_list_df_formatted, all.x=TRUE)

# remove extra columns from data frame
authors_df <- subset(authors_df_initial, select = -c(index,name))
authors_df <- tibble::rowid_to_column(authors_df, "authorID")

# print data frame
authors_df
```

#### 1.1.2 Creating the Article-Authors dataframe
```{r}
# create article-author data frame
authors_df_copy = authors_df_initial[4] %>% 
  dplyr::rename(
    articleID = name,
    )
article_authors_df <- tibble::rowid_to_column(authors_df_copy, "authorID")

# print data frame
article_authors_df
```

#### 1.1.3 Importing Authors and Article-Authors into the database
```{r}
# drop authors table if exists
res <- dbExecute(con, "
  DROP TABLE IF EXISTS authors;
")

# create authors table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS authors
  (
    author_id INTEGER PRIMARY KEY AUTOINCREMENT,
    last_name TEXT NOT NULL,
    first_name TEXT NOT NULL,
    initials TEXT NOT NULL,
    affiliation TEXT NOT NULL
  );
")

# load authors table
res <- dbSendQuery(con, "INSERT INTO authors (author_id, last_name, first_name, initials, affiliation) VALUES (:authorID, :LastName, :FirstName, :Initial, :Affiliation);", authors_df)
res <- dbSendQuery(con, "SELECT * FROM authors LIMIT 5;")
dbFetch(res)
```

```{r}
# drop article_author table if exists
res <- dbExecute(con, "
  DROP TABLE IF EXISTS article_author;
")

# create article_author table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS article_author
  (
    author_id INTEGER,
    article_id INTEGER,
    PRIMARY KEY(article_id, author_id),
    FOREIGN KEY (article_id) REFERENCES articles (article_id),
    FOREIGN KEY (author_id) REFERENCES authors (author_id)
  );
")

# load article authors table
res <- dbSendQuery(con, "INSERT INTO article_author (author_id, article_id) VALUES (:authorID, :articleID);", article_authors_df)
res <- dbSendQuery(con, "SELECT * FROM article_author LIMIT 5;")
dbFetch(res)
```

### 1.1 Journals: Parsing and Importing data
#### 1.1.2 Creating the Journals dataframe

### Creating the journal dataframe
```{r}
# read XML file and parse into DOM
xml_file <- "pubmed_sample.xml"
xmlDOM <- xmlParse(file = xml_file)
xmlRoot <- xmlRoot(xmlDOM)

journalISSN=xpathSApply(xmlRoot,'//Article/Journal/ISSN', xmlValue)
#journalISSN
jISSN=tibble::enframe(journalISSN)

```

```{r}
# read XML file and parse into DOM
xml_file <- "pubmed_sample.xml"
xmlDOM <- xmlParse(file = xml_file)
xmlRoot <- xmlRoot(xmlDOM)
#volume, issue, pubdate
##pubdate could have medline date or could just have year and month 

journalIssue=xpathSApply(xmlRoot,'//Article//Journal/JournalIssue', xmlValue)
#journalIssue
JIssue=tibble::enframe(journalIssue)

```

```{r}
# read XML file and parse into DOM
xml_file <- "pubmed_sample.xml"
xmlDOM <- xmlParse(file = xml_file)
xmlRoot <- xmlRoot(xmlDOM)

journalIssueVolume=xpathSApply(xmlRoot,'//Article//Journal/JournalIssue/Volume', xmlValue)
#journalIssueVolume
JIssueV=tibble::enframe(journalIssueVolume)
```

```{r}
# read XML file and parse into DOM
xml_file <- "pubmed_sample.xml"
xmlDOM <- xmlParse(file = xml_file)
xmlRoot <- xmlRoot(xmlDOM)

journalIssueNumber=xpathSApply(xmlRoot,'//Article//Journal/JournalIssue/Issue', xmlValue)
#journalIssueNumber
JIssueN=tibble::enframe(journalIssueNumber)
```

 
```{r}
# read XML file and parse into DOM
xml_file <- "pubmed_sample.xml"
xmlDOM <- xmlParse(file = xml_file)
xmlRoot <- xmlRoot(xmlDOM)

journalIssuePubDate=xpathSApply(xmlRoot,'//Article//Journal/JournalIssue/PubDate', xmlValue)
#journalIssuePubDate
jIPubDate=tibble::enframe(journalIssuePubDate)

```

```{r}
# read XML file and parse into DOM
xml_file <- "pubmed_sample.xml"
xmlDOM <- xmlParse(file = xml_file)
xmlRoot <- xmlRoot(xmlDOM)

JTitle=xpathSApply(xmlRoot,'//Article//Title', xmlValue)
#journalIssuePubDate
jTitleNew=tibble::enframe(JTitle)
#jTitleNew
```

```{r}
# read XML file and parse into DOM
xml_file <- "pubmed_sample.xml"
xmlDOM <- xmlParse(file = xml_file)
xmlRoot <- xmlRoot(xmlDOM)

ISOAbbrev=xpathSApply(xmlRoot,'//Article//ISOAbbreviation', xmlValue)
#journalIssuePubDate
jISOAbbrev=tibble::enframe(ISOAbbrev)
#jISOAbbrev
```

```{r}
Journal_df=data.frame(Journal_ISSN=jISSN[2],Journal_Issue_Volume=JIssueV[2],Journal_Issue_Number=JIssueN[2],Journal_Issue_PubDate=jIPubDate[2],title=jTitleNew[2],JIsoabbreviation=jISOAbbrev[2])
Journal_df

final_Journal_df=Journal_df %>% 
  dplyr::rename(
    ISSN = value,
    Volume = value.1,
    Issue=value.2,
    PubDate=value.3,
    title=value.4,
    ISOAbbrev=value.5
    )

```
## Journal DF
```{r}
article_journal_initial_df <- tibble::rowid_to_column(final_Journal_df, "journalID")
article_journal_initial_df
```

## Creating the history dataframe
```{r}
# pads with zeroes
padstring=function(x){
  x <-xmlValue(x)
  #print(x)
 if (nchar(x)==1){
    return(paste0('0',x))
  }
  
  return (x)
}
```

```{r}
# Takes an xml node and it returns the value and pubstatus attribute of that node. Also pads the date string
get_pub_status_and_value=function(xmlNode){
  #print(xmlNode)
    x<-newXMLDoc(xmlNode)
    #xmlNodecopy <- duplicate(xmlNode)
    #y<<-xmlNodecopy
    vec=xpathSApply(x,'//PubMedPubDate/*',padstring)
    datestring=paste(vec, collapse = '')
  return (paste(datestring, xmlGetAttr(xmlNode,'PubStatus'),sep='|'))
}
```

```{r}
## pointer is a pointer to a subtree. 
history_columns=function(xmlNode){
    #made a brand new tree of the subtree
    x<-newXMLDoc(xmlNode)
    # for each pointer
    ## getting all the pubmedubdate information of subtree
   ## vec is a pipe delimited pubstatus
    vec=xpathSApply(x,'//PubMedPubDate',get_pub_status_and_value)
    ## collapse the vector into a single string separated by stars
  return (paste(vec,collapse='*'))
}
```


```{r}
## find the pubmeddata of each article
history=xpathSApply(xmlRoot,'//PubmedArticle//PubmedData/History', history_columns)
#history
```

```{r}
#VEctor of p1,p2,p3,p4.....p10
## tidyverse/tidyr
## pivot longer-one piece of data per row. Takes each column per row
## 
history_prelim_df=tibble::enframe(history)%>%  separate(value,paste0('p',seq(10)),sep='\\*') %>% pivot_longer(!name,names_to='index',values_to='data') %>% filter(!is.na(data)) %>% separate(col=data, into = c('Date','PubStatus'),sep='\\|')


```

```{r}
history_prelim_df
```


```{r}
final_date_column=history_prelim_df %>% transmute(newDate=ymd(substr(Date,1,8)))
final_date_column
```

```{r}
new_history_prelim_df=data.frame(publishStatus=history_prelim_df[4],DateColumn=final_date_column)
new_history_prelim_df
```
## History DF
```{r}
final_history_prelim_df <- tibble::rowid_to_column(new_history_prelim_df, "historyID")
final_history_prelim_df 
```

## Creating the article history dataframe
```{r}
articleID=history_prelim_df[1]
articleID %>% 
  dplyr::rename(
    article_id = name,
    )
newarticleID=articleID

```


## articlehistory DF
```{r}
article_history_df=data.frame(historyid=final_history_prelim_df[1],articleidentifier=newarticleID)
article_history_df %>% 
  dplyr::rename(
    articleid = name
    )

```





### Creating the abstract dataframe

```{r}
#trying to get all pub statuses for each pubmedarticle and pubmed data
##Getting all the abstract
abstract=xpathSApply(xmlRoot,'//PubmedArticle//Article/Abstract', xmlValue)
#aabstract
```

```{r}
abstract_new=function(xmlNode){
  #print(xmlNode)
    xmlNodecopy <- duplicate(xmlNode)
    x<-newXMLDoc(xmlNodecopy)
    xmlNodecopy1 <- duplicate(xmlNode)
    y<-newXMLDoc(xmlNodecopy1)
    xmlNodecopy2 <- duplicate(xmlNode)
    z<-newXMLDoc(xmlNodecopy2)
    #y<<-xmlNodecopy
    vec=xpathSApply(x,'//AbstractText',xmlGetAttr,'Label')
    vec1=xpathSApply(y,'//AbstractText',xmlGetAttr,'NlmCategory')
    vec2=xpathSApply(z,'//AbstractText',xmlValue)
    

    #datestring=paste(vec, collapse = '')
  return (paste(vec,vec1,vec2, collapse='|',sep='*'))
}
```

```{r}
  abstract_df=xpathSApply(xmlRoot,'//Article',abstract_new)
  #abstract_df
```

```{r}
abstract_df_new=tibble::enframe(abstract_df) %>%  separate(value,paste0('a',seq(10)),sep='\\|') %>% pivot_longer(!name, names_to='index',values_to='data') %>% filter(!is.na(data)) %>% separate(col=data, into = c('label','nlmCategory','content'),sep='\\*')
```

```{r}
abstract_df_new 
```
### Create the article abstract df
```{r}
abstract_df_new_done=abstract_df_new %>% 
  dplyr::rename(
    articleID = name,
    )
abstract_df_new_done
```
```{r}
abstract_df_new_trans <- subset( abstract_df_new_done, select = -c(index))
abstract_df_new_trans
```

```{r}
abstract_df_new_trans <- tibble::rowid_to_column( abstract_df_new_trans, "abstractID")
abstract_df_new_trans
```
## Abstract DF
```{r}
abstract_all <- subset(abstract_df_new_trans, select = -c(articleID))
abstract_all
```

## abstract article
```{r}
abstract_df_new_all <- subset(abstract_df_new_trans, select = -c(label,nlmCategory,content))
abstract_df_new_all
```


### Creating the elocation  dataframe
```{r}
elocation=xpathSApply(xmlRoot,'//ELocationID', xmlValue)
#elocation
```



```{r}
# Takes an xml node and it returns the value and pubstatus attribute of that node. Also pads the date string
geloc=function(xmlNode){
  #print(xmlNode)
    xmlNodecopy <- duplicate(xmlNode)
    x<-newXMLDoc(xmlNodecopy)
    xmlNodecopy1 <- duplicate(xmlNode)
    y<-newXMLDoc(xmlNodecopy1)
    #y<<-xmlNodecopy
    vec=xpathSApply(x,'//ELocationID',xmlGetAttr,'EIdType')
    vec1=xpathSApply(y,'//ELocationID',xmlValue)

    #datestring=paste(vec, collapse = '')
  return (paste(vec,vec1, collapse='|',sep='*'))
}
```

```{r}
  elocation_df=xpathSApply(xmlRoot,'//Article',geloc)
  #elocation_df
```

```{r}
  elocation_df_new=tibble::enframe(  elocation_df)%>%  separate(value,paste0('e',seq(10)),sep='\\|') %>% pivot_longer(!name,names_to='index',values_to='data') %>% filter(!is.na(data)) %>% separate(col=data, into = c('type','content'),sep='\\*')
```
```{r}
  elocation_df_new
```


```{r}
 elocation_df_new <- tibble::rowid_to_column( elocation_df_new, "elocID")
 elocation_df_new
```


```{r}
 elocation_df_new <- subset( elocation_df_new, select = -c(name,index))

```

```{r}
 elocation_df_new
 test_elocation_df_new=elocation_df_new %>% distinct(type)
 test_elocation_df_new
 test_elocation_df_new_final <- tibble::rowid_to_column( test_elocation_df_new, "elocID")
 test_elocation_df_new_final
```
```{r}
datC <- merge( test_elocation_df_new_final,  elocation_df_new, all.x=TRUE)
datC
```
## elocation DF


```{r}
#elocation_df_final_df=datC %>% 
  #dplyr::rename(
  #  articleID = elocID,
   # elocID=typeID
    #)
```
### Creating the article elocation  dataframe

```{r}

elocation_df_final_df_done <- subset( elocation_df_final_df, select = -c(type,content))
elocation_df_final_df_done
```

```{r}
#elocation_df_done <- #data.frame(articleid=elocation_df_final_df[3],elocid=elocation_df_final_df[2])
#elocation_df_done
```
### Creating Publication Type Dataframe
```{r}
pubtype=xpathSApply(xmlRoot,'//PublicationTypeList', xmlValue)
#pubtype
```


```{r}
get_pub_type=function(xmlNode){
  #print(xmlNode)
    gtb<-newXMLDoc(xmlNode)
    #xmlNodecopy <- duplicate(xmlNode)
    #y<<-xmlNodecopy
    PublicationTypeList=xpathSApply(gtb,'//PublicationTypeList/*',xmlValue)
  return (paste(PublicationTypeList))
}
```

```{r}
pubtype_columns=function(xmlNode){
    #made a brand new tree of the subtree
    #print(xmlNode)

    pb<-newXMLDoc(xmlNode)
    # for each pointer
    ## getting all the pubmedubdate information of subtree
   ## vec is a pipe delimited pubstatus
    pubvec=xpathSApply(pb,'//PublicationTypeList',get_pub_type)
    ## collapse the vector into a single string separated by stars
  return (paste(pubvec,collapse='*'))
}
```



```{r}
pubtype_new=xpathSApply(xmlRoot,'//PubmedArticle//PublicationTypeList', pubtype_columns)
#pubtype_new
```

```{r}
pubtype_new_df=tibble::enframe(pubtype_new)%>%
  separate(value,paste0('p',seq(10)),sep='\\*') %>%
  pivot_longer(!name,names_to='index',values_to='data') %>% filter(!is.na(data)) %>% separate(col=data, into = c('type'),sep='\\*')
pubtype_new_df

#pubvec1=xpathSApply(xmlRoot,'//PublicationTypeList',xmlValue)

```

```{r}
pubtype_new_df_prelim <- subset(pubtype_new_df, select = -c(index))
#pubtype_new_df_prelim
```


```{r}
pubtype_new_df_prelim_new=pubtype_new_df_prelim %>% 
  dplyr::rename(
    articleID = name
    )
```

```{r}
newdf=pubtype_new_df_prelim_inp
```

```{r}
pubtype_new_df_prelim_inp_distinct=pubtype_new_df_prelim_inp %>% distinct(type)
#pubtype_new_df_prelim_inp_distinct
```

## PubType DF
```{r}
pubtype_new_df_final <- tibble::rowid_to_column(pubtype_new_df_prelim_inp_distinct, "pubTypeID")
pubtype_new_df_final
```

### Creating Article Pub Type Dataframe
```{r}
datP <- merge(pubtype_new_df_final,  pubtype_new_df_prelim_new, all.x=TRUE)
#datP
```
## Article Pub Type
```{r}
pubtype_new_df_final_done <- subset(datP, select = -c(type))
pubtype_new_df_final_done
```

## Creating Grant Dataframe-in progress
```{r}
grant=xpathSApply(xmlRoot,'//Grant', xmlValue)
```

```{r}
get_grant=function(xmlNode){
 # print(xmlNode)
    xmlNodecopy2 <- duplicate(xmlNode)
    gg<-newXMLDoc(xmlNodecopy2)
    #y<<-xmlNodecopy
    grantId=xpathSApply(gg,'//GrantID',xmlValue)
    acronym=xpathSApply(gg,'//Acronym',xmlValue)
    agency=xpathSApply(gg,'//Agency',xmlValue)
    country=xpathSApply(gg,'//Country',xmlValue)

  return (paste(grantId,acronym,agency,country, sep='*'))
}
```

```{r}
grant_columns=function(xmlNode){
    #made a brand new tree of the subtree
    #print(xmlNode)
    newxmlNodecopy2 <- duplicate(xmlNode)
    gc<-newXMLDoc(newxmlNodecopy2)
    # for each pointer
    ## getting all the pubmedubdate information of subtree
   ## vec is a pipe delimited pubstatus
    grantvec=xpathSApply(gc,'//Grant',get_grant)
    ## collapse the vector into a single string separated by stars
  return (paste(grantvec,collapse='|'))
}
```


```{r}
get_grant_test=function(xmlNode){
  xmlNodecopy3 <- duplicate(xmlNode)
  gd<-newXMLDoc(xmlNodecopy3)
  grant_check= xpathSApply(gd,'//GrantList', grant_columns)

  if(length(grant_check)==0){
    return ("")
  }
  return (grant_check)

}



```

```{r}
grant_list_a = xpathSApply(xmlRoot,'//Article', get_grant_test)
#grant_list_a
```

```{r}
  grant_list_a_new=tibble::enframe(grant_list_a )%>%  separate(value,paste0('g',seq(10)),sep='\\|') %>% pivot_longer(!name,names_to='index',values_to='data') %>% filter(!is.na(data)) %>% separate(col=data, into = c('grantid','acronym','agency','country'),sep='\\*')
```

```{r}
grant_list_a_new
```

```{r}
grant_df_in_p_1 <- tibble::rowid_to_column(grant_df_in_p, "articleID")
grant_df_in_p_1

```
```{r}
grant_df_resolved<- data.frame(articleid=grant_df_in_p_1[2],grantid=grant_df_in_p_1[4],acronym=grant_df_in_p_1[5],agency=grant_df_in_p_1[6],country=grant_df_in_p_1[7])
grant_df_resolved
```
```{r}
grant_df_resolved_final=grant_df_resolved %>% 
  dplyr::rename(
      articleid=name
    )
grant_df_resolved_final
```
##Grant DF
```{r}
grant_df_resolved_done=grant_df_resolved %>% distinct(grantid,agency,acronym)
grant_df_resolved_done
```


## Article grant dataframe
```{r}
article_grant_df_final <- data.frame(articleid=grant_df_resolved_final[1],journalid=grant_df_resolved_final[2])
#article_grant_df_final
article_grant_df_final_done=article_grant_df_final %>% distinct(articleid,grantid)
article_grant_df_final_done
```
## Creating the article dataframe

```{r}
articleDetails = xpathSApply(xmlRoot,'//Article', xmlValue)
#articleDetails
#tibble::enframe(articleDetails)

```

```{r}
final_Journal_df
```

```{r}
articlepubModel = xpathSApply(xmlRoot,'//Article', xmlGetAttr,'PubModel')
#articlepubModel
```


```{r}
articletitle = xpathSApply(xmlRoot,'//Article/ArticleTitle', xmlValue)
#articletitle
```
```{r}
articlep= xpathSApply(xmlRoot,'//Article/Pagination', xmlValue)
articlep
```


```{r}
get_date=function(xmlNode){
  xmlNodecopy3 <- duplicate(xmlNode)
  gd<-newXMLDoc(xmlNodecopy3)
  get_date_check= xpathSApply(gd,'//ArticleDate', xmlValue)

  if(length(get_date_check)==0){
    return ("")
  }
  return (get_date_check)

}

```


```{r}
articled= xpathSApply(xmlRoot,'//Article', get_date)
articled
```

```{r}
articlel= xpathSApply(xmlRoot,'//Article/Language', xmlValue)
#articlel
```

```{r}
grabbing_index <- tibble::rowid_to_column(final_Journal_df, "articleID")
#grabbing_index
#articlel
#unlist(grabbing_index[1])
```


```{r}
article_df_final <- data.frame(articleid=grabbing_index[1],journalid=grabbing_index[2],pubModel=articlepubModel,articleTitle=articletitle,pagination=articlep,date=articled,language=articlel)
article_df_final
```
## Article DF
```{r}
article_df_final$date=ymd(article_df_final$date)
article_df_final
```

### Creating a database and tables

```{r}

# CREATE TABLES
# create journals table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS journals
  (
    journal_id INTEGER PRIMARY KEY AUTOINCREMENT,
    issn TEXT NOT NULL,
    volume TEXT NOT NULL,
    issue INTEGER NOT NULL,
    pub_date DATE NOT NULL,
    title TEXT NOT NULL,
    iso_abbrev TEXT NOT NULL
  );
")

# create articles table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS articles
  (
    article_id INTEGER PRIMARY KEY AUTOINCREMENT,
    journal_id TEXT,
    pub_model TEXT NOT NULL,
    title TEXT NOT NULL,
    pagination INTEGER NOT NULL,
    pub_date DATE NOT NULL,
    lang TEXT NOT NULL,
    FOREIGN KEY (journal_id) REFERENCES journalS (journal_id)
  );
")

# create authors table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS authors
  (
    author_id INTEGER PRIMARY KEY AUTOINCREMENT,
    last_name TEXT NOT NULL,
    first_name TEXT NOT NULL,
    initials TEXT NOT NULL,
    affiliation TEXT NOT NULL
  );
")

# create article authorship table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS article_author
  (
    article_id INTEGER,
    author_id INTEGER,
    PRIMARY KEY(article_id, author_id),
    FOREIGN KEY (article_id) REFERENCES articles (article_id),
    FOREIGN KEY (author_id) REFERENCES authors (author_id)
  );
")

# create history table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS history
  (
    history_id INTEGER PRIMARY KEY AUTOINCREMENT,
    pub_date DATE NOT NULL,
    pub_status TEXT NOT NULL
  );
")

# create article history table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS article_history
  (
    article_id INTEGER,
    history_id INTEGER,
    PRIMARY KEY(article_id, history_id),
    FOREIGN KEY (article_id) REFERENCES articles (article_id),
    FOREIGN KEY (history_id) REFERENCES history (history_id)
  );
")

# create abstracts table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS abstracts
  (
    abstract_id INTEGER PRIMARY KEY AUTOINCREMENT,
    label TEXT NOT NULL,
    nml_category TEXT NOT NULL,
    content TEXT NOT NULL
  );
")

# create article abstracts table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS article_abstract
  (
    abstract_id INTEGER,
    article_id INTEGER,
    PRIMARY KEY(article_id, abstract_id),
    FOREIGN KEY (article_id) REFERENCES articles (article_id),
    FOREIGN KEY (abstract_id) REFERENCES abstracts (abstract_id)
  );
")

# create elocations table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS elocations
  (
    elocation_id INTEGER PRIMARY KEY AUTOINCREMENT,
    eloc_type TEXT NOT NULL,
    content TEXT NOT NULL
  );
")

# create elocations table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS article_elocations
  (
    article_id INTEGER,
    elocation_id INTEGER,
    PRIMARY KEY(article_id, elocation_id),
    FOREIGN KEY (article_id) REFERENCES articles (article_id),
    FOREIGN KEY (elocation_id) REFERENCES elocations (elocation_id)
  );
")

# create publication types table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS pub_types
  (
    pub_type_id INTEGER PRIMARY KEY AUTOINCREMENT,
    pub_type TEXT NOT NULL
  );
")

# create article publication types table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS article_pub_type
  (
    pub_type_id INTEGER,
    article_id INTEGER,
    PRIMARY KEY(article_id, pub_type_id),
    FOREIGN KEY (article_id) REFERENCES articles (article_id),
    FOREIGN KEY (pub_type_id) REFERENCES pub_types (pub_type_id)
  );
")

# create grants table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS grants
  (
    grant_id TEXT PRIMARY KEY,
    acronym TEXT NOT NULL,
    agency TEXT NOT NULL,
    country TEXT NOT NULL
  );
")

# create article grants table
res <- dbExecute(con, "
  CREATE TABLE IF NOT EXISTS article_grant
  (
    article_id INTEGER,
    grant_id TEXT,
    PRIMARY KEY(article_id, grant_id),
    FOREIGN KEY (article_id) REFERENCES articles (article_id),
    FOREIGN KEY (grant_id) REFERENCES grants (grant_id)
  );
")
```

## Loading data into the database
Since I have already created the tables, I will load the `Book` data frame by using placeholders in the query definition and matching each value to columns in the data frame. I will repeat this step for each table.

```{r}
# load journals table
res <- dbSendQuery(con, "INSERT INTO journals (journal_id, issn, volume, issue, pub_date, title, iso_abbrev) VALUES (:journalID, :ISSN, :Volume, :Issue, :PubDate, :title, :ISOAbbrev);", article_journal_initial_df)
res <- dbSendQuery(con, "SELECT * FROM journals LIMIT 5;")
dbFetch(res)
```

```{r}
# load articles table
res <- dbSendQuery(con, "INSERT INTO articles (article_id, journal_id, pub_model, title, pagination, pub_date, lang) VALUES (:articleid, :journalid, :pubModel, :articleTitle, :pagination, :date, :language);", article_df_final)
res <- dbSendQuery(con, "SELECT * FROM history LIMIT 5;")
dbFetch(res)
```

```{r}
# load authors table
res <- dbSendQuery(con, "INSERT INTO authors (author_id, last_name, first_name, initials, affiliation) VALUES (:newDate, :PubStatus);", daAuthor)
res <- dbSendQuery(con, "SELECT * FROM authors LIMIT 5;")
dbFetch(res)
```

```{r}
# load article authors table
res <- dbSendQuery(con, "INSERT INTO article_author (author_id, article_id) VALUES (:authorID, :areticleID);", dArticle_Authors)
res <- dbSendQuery(con, "SELECT * FROM history LIMIT 5;")
dbFetch(res)
```

```{r}
# load history table
res <- dbSendQuery(con, "INSERT INTO history (pub_date, pub_status) VALUES (:newDate, :PubStatus);", new_history_prelim_df)
res <- dbSendQuery(con, "SELECT * FROM history LIMIT 5;")
dbFetch(res)
```

```{r}
# load article history
res <- dbSendQuery(con, "INSERT INTO article_history (article_id, history_id) VALUES (:name, :historyID);", article_history_df)
res <- dbSendQuery(con, "SELECT * FROM article_history LIMIT 5;")
dbFetch(res)
```


```{r}
# load abstracts
res <- dbSendQuery(con, "INSERT INTO abstracts (abstract_id, label, nml_category, content) VALUES (:abstractID, :label, :nlmCategory, :content);", abstract_all)
res <- dbSendQuery(con, "SELECT * FROM abstracts LIMIT 5;")
dbFetch(res)
```

```{r}
# load abstract article
res <- dbSendQuery(con, "INSERT INTO article_abstract (abstract_id, article_id) VALUES (:abstractID, :articleID);", abstract_df_new_all)
res <- dbSendQuery(con, "SELECT * FROM article_abstract LIMIT 5;")
dbFetch(res)
```

```{r}
# load elocations
res <- dbSendQuery(con, "INSERT INTO elocations (elocation_id, eloc_type, content) VALUES (:elocationID, :elocationType, :content);", test_elocation_df_new_final)
res <- dbSendQuery(con, "SELECT * FROM elocations LIMIT 5;")
dbFetch(res)
```

```{r}
# load article elocations
res <- dbSendQuery(con, "INSERT INTO article_elocations (article_id, elocation_id) VALUES (:elocationID, :articleID);", elocation_df_final_df_done)
res <- dbSendQuery(con, "SELECT * FROM elocations LIMIT 5;")
dbFetch(res)
```

```{r}
# load publication types
res <- dbSendQuery(con, "INSERT INTO pub_types (pub_type_id, pub_type) VALUES (:pubTypeID, :type);", pubtype_new_df_final)
res <- dbSendQuery(con, "SELECT * FROM elocations LIMIT 5;")
dbFetch(res)
```

```{r}
# load article publication types
res <- dbSendQuery(con, "INSERT INTO article_pub_type (pub_type_id, article_id) VALUES (:pubTypeID, :articleID);", pubtype_new_df_final_done)
res <- dbSendQuery(con, "SELECT * FROM article_pub_type LIMIT 5;")
dbFetch(res)
```